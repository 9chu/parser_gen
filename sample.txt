term Plus assoc(left) prec(1);  // +
term Minus assoc(left) prec(1);  // -
term Multiply assoc(left) prec(2);  // *
term Division assoc(left) prec(2);  // /
term LeftParen;  // (
term RightParen;  // )
term Identifier {% Tokenizer::Token %};
term LiteralNumber {% Tokenizer::Token %};

nonterm exp {% Ast::ExpressionPtr %};

grammar {
    // entry rules
    exp -> Identifier(token) {%
        auto rvalue = std::make_shared<Ast::RValueRef>(std::get<std::string>(token));
        return std::static_pointer_cast<Ast::Expression>(rvalue);
    %};
    exp -> LiteralNumber(token) {%
        auto number = std::make_shared<Ast::NumberLiteral>(std::get<double>(token));
        return std::static_pointer_cast<Ast::Expression>(number);
    %};
    exp -> LeftParen exp(exp) RightParen {% return exp; %};
    exp -> Minus exp(rhs) prec(10) {%
        auto unary = std::make_shared<Ast::UnaryExpression>(rhs, Ast::UnaryOp::Negative);
        return std::static_pointer_cast<Ast::Expression>(unary);
    %};
    exp -> exp(lhs) Plus exp(rhs) {%
        auto binexp = std::make_shared<Ast::BinaryExpression>(lhs, rhs, Ast::BinaryOp::Plus);
        return std::static_pointer_cast<Ast::Expression>(binexp);
    %};
    exp -> exp(lhs) Minus exp(rhs) {%
        auto binexp = std::make_shared<Ast::BinaryExpression>(lhs, rhs, Ast::BinaryOp::Minus);
        return std::static_pointer_cast<Ast::Expression>(binexp);
    %};
    exp -> exp(lhs) Multiply exp(rhs) {%
        auto binexp = std::make_shared<Ast::BinaryExpression>(lhs, rhs, Ast::BinaryOp::Multiply);
        return std::static_pointer_cast<Ast::Expression>(binexp);
    %};
    exp -> exp(lhs) Division exp(rhs) {%
        auto binexp = std::make_shared<Ast::BinaryExpression>(lhs, rhs, Ast::BinaryOp::Division);
        return std::static_pointer_cast<Ast::Expression>(binexp);
    %};
};

generator {%
    {
        "includes": [
            "Test.hpp"
        ]
    }
%};
