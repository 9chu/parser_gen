term plus assoc(left) prec(1);  // +
term minus assoc(left) prec(1);  // -
term mul assoc(left) prec(2);  // *
term div assoc(left) prec(2);  // /
term lp;  // (
term rp;  // )
term id {% Tokenizer::Token %};
term number {% Tokenizer::Token %};

nonterm Expression {% Ast::ExpressionPtr %};

grammar {
    // entry rules
    Expression -> id(token) {%
        auto rvalue = std::make_shared<Ast::RValueRef>(std::get<std::string>(token));
        return std::static_pointer_cast<Ast::Expression>(rvalue);
    %};
    Expression -> number(token) {%
        auto number = std::make_shared<Ast::NumberLiteral>(std::get<double>(token));
        return std::static_pointer_cast<Ast::Expression>(number);
    %};
    Expression -> lp Expression(exp) rp {% return exp; %};
    Expression -> minus Expression(rhs) prec(10) {%
        auto unary = std::make_shared<Ast::UnaryExpression>(rhs, Ast::UnaryOp::Minus);
        return std::static_pointer_cast<Ast::Expression>(unary);
    %};
    Expression -> Expression(lhs) plus Expression(rhs) {%
        auto binexp = std::make_shared<Ast::BinaryExpression>(lhs, rhs, Ast::BinaryOp::Plus);
        return std::static_pointer_cast<Ast::Expression>(binexp);
    %};
    Expression -> Expression(lhs) minus Expression(rhs) {%
        auto binexp = std::make_shared<Ast::BinaryExpression>(lhs, rhs, Ast::BinaryOp::Minus);
        return std::static_pointer_cast<Ast::Expression>(binexp);
    %};
    Expression -> Expression(lhs) mul Expression(rhs) {%
        auto binexp = std::make_shared<Ast::BinaryExpression>(lhs, rhs, Ast::BinaryOp::Multiply);
        return std::static_pointer_cast<Ast::Expression>(binexp);
    %};
    Expression -> Expression(lhs) div Expression(rhs) {%
        auto binexp = std::make_shared<Ast::BinaryExpression>(lhs, rhs, Ast::BinaryOp::Division);
        return std::static_pointer_cast<Ast::Expression>(binexp);
    %};
};
